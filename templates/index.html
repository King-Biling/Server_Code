<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ™ºèƒ½å°è½¦ç›‘æ§ç³»ç»Ÿ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
            padding: 20px;
        }

        .container {
            display: flex;
            max-width: 1800px;
            margin: 0 auto;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        /* åæ ‡å›¾åŒºåŸŸ */
        .coordinate-map {
            flex: 3;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .map-header {
            padding: 15px 20px;
            background: #2c3e50;
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .map-header h1 {
            font-size: 20px;
        }

        #coordinateCanvas {
            flex: 1;
            background: #f8f9fa;
            cursor: pointer;
        }

        /* ä¾§è¾¹æ  - ä¸¤åˆ—å¸ƒå±€ */
        .sidebar {
            flex: 2;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            padding: 20px;
            display: flex;
            flex-direction: column;
            min-width: 600px;
            max-width: 800px;
            /* æ·»åŠ æ•´ä½“æ»šåŠ¨ */
            overflow: hidden;
        }

        .sidebar-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding-right: 5px;
        }

        /* è‡ªå®šä¹‰æ»šåŠ¨æ¡ */
        .sidebar-content::-webkit-scrollbar {
            width: 6px;
        }

        .sidebar-content::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }

        .sidebar-content::-webkit-scrollbar-thumb {
            background: #c1c1c1;
            border-radius: 3px;
        }

        .sidebar-content::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }

        .sidebar-columns {
            display: flex;
            gap: 20px;
            flex: 1;
            min-height: 0; /* é‡è¦ï¼šå…è®¸å†…å®¹æ”¶ç¼© */
        }

        .sidebar-left {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .sidebar-right {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0;
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #eee;
            flex-shrink: 0; /* é˜²æ­¢å¤´éƒ¨è¢«å‹ç¼© */
        }

        .header h1 {
            color: #2c3e50;
            font-size: 24px;
            margin-bottom: 5px;
        }

        /* å¯æŠ˜å é¢æ¿ */
        .collapsible-section {
            margin-bottom: 15px;
            border-radius: 10px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            flex-shrink: 0; /* é˜²æ­¢é¢æ¿è¢«å‹ç¼© */
        }

        .section-header {
            background: #2c3e50;
            color: white;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
            transition: background 0.3s ease;
        }

        .section-header:hover {
            background: #34495e;
        }

        .section-header::after {
            content: 'â–¼';
            font-size: 12px;
            transition: transform 0.3s ease;
        }

        .section-header.collapsed::after {
            transform: rotate(-90deg);
        }

        .section-content {
            background: white;
            padding: 0;
            max-height: 0;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .section-content.expanded {
            padding: 15px;
            max-height: 1000px;
            overflow-y: auto;
        }

        /* å°è½¦åˆ—è¡¨ */
        .car-list {
            height: 400px; /* å››è¾†å°è½¦çš„é«˜åº¦ */
            flex: 1;
            overflow-y: auto;
            margin-bottom: 0;
        }

        .car-item {
            background: white;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
            border-left: 4px solid #4CAF50;
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .car-item:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.12);
        }

        .car-item.disconnected {
            border-left-color: #f56565;
            opacity: 0.7;
        }

        .car-item.selected {
            background: #f0f9ff;
            border-left-color: #2196F3;
        }

        .car-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .car-id {
            font-weight: bold;
            font-size: 15px;
            color: #2d3748;
        }

        .car-status {
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
        }

        .status-connected {
            background: #c6f6d5;
            color: #22543d;
        }

        .status-disconnected {
            background: #fed7d7;
            color: #742a2a;
        }

        .car-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            font-size: 12px;
        }

        .detail-item {
            display: flex;
            flex-direction: column;
        }

        .detail-label {
            font-size: 10px;
            color: #718096;
            margin-bottom: 1px;
        }

        .detail-value {
            font-weight: 600;
            color: #2d3748;
        }

        /* ç”µæ± æ ·å¼ */
        .battery {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .battery-level {
            width: 30px;
            height: 12px;
            background: #e2e8f0;
            border-radius: 2px;
            overflow: hidden;
            position: relative;
        }

        .battery-fill {
            height: 100%;
            background: #48bb78;
            transition: width 0.3s ease;
        }

        .battery-low {
            background: #f56565;
        }

        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            background: white;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.08);
        }

        .control-section {
            margin-bottom: 12px;
        }

        .control-section:last-child {
            margin-bottom: 0;
        }

        .control-section h3 {
            margin-bottom: 6px;
            color: #4a5568;
            font-size: 14px;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 4px;
        }

        /* ä½ç½®æ§åˆ¶ */
        .position-control {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
        }

        .coord-input {
            padding: 5px;
            border: 1px solid #cbd5e0;
            border-radius: 5px;
            font-size: 12px;
            width: 100%;
        }

        .action-btn {
            width: 100%;
            padding: 7px;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 6px;
            transition: background 0.2s ease;
            font-size: 12px;
        }

        .action-btn:hover {
            background: #2980b9;
        }

        /* å¹¿æ’­æ§åˆ¶æŒ‰é’® */
        .broadcast-controls {
            display: flex;
            gap: 6px;
            align-items: center;
        }

        .broadcast-btn {
            flex: 1;
            padding: 7px;
            border: none;
            border-radius: 5px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .broadcast-on {
            background: #48bb78;
            color: white;
        }

        .broadcast-off {
            background: #f56565;
            color: white;
        }

        .broadcast-btn:hover {
            transform: scale(1.02);
        }

        .broadcast-btn:active {
            transform: scale(0.98);
        }

        .broadcast-btn.inactive {
            background: #cbd5e0;
            color: #718096;
        }

        .broadcast-status {
            font-size: 11px;
            color: #718096;
            margin-top: 4px;
            text-align: center;
        }

        /* æ€§èƒ½ç›‘æ§ */
        .performance-info {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background: rgba(255,255,255,0.9);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* å°è½¦è¯¦æƒ…å¼¹çª— */
        .car-popup {
            position: absolute;
            background: white;
            border-radius: 8px;
            padding: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            z-index: 1000;
            max-width: 220px;
            display: none;
        }

        .car-popup h3 {
            margin-bottom: 6px;
            color: #2c3e50;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
            font-size: 14px;
        }

        .popup-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            font-size: 11px;
        }

        .popup-close {
            position: absolute;
            top: 6px;
            right: 6px;
            background: none;
            border: none;
            font-size: 12px;
            cursor: pointer;
            color: #718096;
        }

        /* è§’åº¦æŒ‡ç¤ºå™¨ */
        .angle-indicator {
            position: absolute;
            bottom: 15px;
            left: 15px;
            background: rgba(255,255,255,0.9);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 11px;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* é€Ÿåº¦æ˜¾ç¤ºæ ·å¼ */
        .speed-info {
            font-size: 9px;
            color: #4a5568;
            line-height: 1.2;
        }

        .velocity-components {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1px;
            font-size: 8px;
            margin-top: 1px;
        }

        /* æ‹“æ‰‘çŸ©é˜µæ ·å¼ */
        .topology-matrix {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 3px;
            margin-bottom: 6px;
        }

        .matrix-header {
            text-align: center;
            font-weight: bold;
            padding: 3px;
            background: #f7fafc;
            font-size: 10px;
        }

        .matrix-cell {
            text-align: center;
        }

        .matrix-cell input {
            width: 100%;
            text-align: center;
            font-size: 10px;
            padding: 2px;
        }

        .visibility-info {
            margin-top: 6px;
            padding: 6px;
            background: #f8f9fa;
            border-radius: 4px;
            font-size: 9px;
            line-height: 1.2;
        }

        /* ç³»ç»ŸçŠ¶æ€æ  */
        .system-status {
            margin-top: 15px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 6px;
            font-size: 10px;
            text-align: center;
            color: #4a5568;
            flex-shrink: 0; /* é˜²æ­¢åº•éƒ¨çŠ¶æ€æ è¢«å‹ç¼© */
        }

        /* ç´§å‡‘å¸ƒå±€è°ƒæ•´ */
        .compact-control {
            padding: 8px;
        }

        .compact-control .control-section {
            margin-bottom: 10px;
        }

        /* ä¸¤åˆ—å¸ƒå±€ä¸­çš„é«˜åº¦æ§åˆ¶ */
        .scrollable-content {
            overflow-y: auto;
            flex: 1;
        }

        /* å³ä¾§æ§åˆ¶é¢æ¿çš„å¸ƒå±€ä¼˜åŒ– */
        .right-controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* å·¦ä¾§é¢æ¿æ»šåŠ¨ä¼˜åŒ– */
        .left-panel-content {
            flex: 1;
            overflow-y: auto;
        }

        /* é˜Ÿå½¢é¢„è§ˆæ ·å¼ */
        .formation-preview-container {
            margin-top: 10px;
            text-align: center;
            width: 100%;
        }
        
        #formationPreviewCanvas {
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #f8f9fa;
            margin: 5px auto;
            display: block;
            width: 100%;
            height: 150px;
        }
        
        .preview-info {
            font-size: 10px;
            color: #666;
            margin-top: 3px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <div class="header">
                <h1>æ™ºèƒ½ç¾¤ä½“æœºå™¨äººååŒæ§åˆ¶å®éªŒå¹³å°</h1>
            </div>

            <div class="sidebar-content">
                <div class="sidebar-columns">
                    <div class="sidebar-left">
                        <div class="collapsible-section">
                            <div class="section-header" onclick="toggleSection('carListSection')">
                                æ™ºèƒ½å°è½¦ç›‘æ§
                            </div>
                            <div class="section-content expanded" id="carListSection">
                                <div class="car-list left-panel-content" id="carList">
                                    <div class="no-cars" style="text-align: center; color: #718096; padding: 15px;">
                                        ç­‰å¾…è¿æ¥...
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="collapsible-section">
                                <div class="section-header" onclick="toggleSection('formationControlSection')">
                                    ç¼–é˜Ÿæ§åˆ¶
                                </div>
                                <div class="section-content expanded" id="formationControlSection">
                                    <div class="control-panel compact-control">
                                        <div class="control-section">
                                            <h3>ç¼–é˜Ÿè®¾ç½®</h3>
                                            <div style="margin-bottom: 8px;">
                                                <label>é¢†èˆªè€…:</label>
                                                <select id="leaderSelector" class="coord-input">
                                                    <option value="CAR1">ROBOT#1</option>
                                                    <option value="CAR2">ROBOT#2</option>
                                                    <option value="CAR3">ROBOT#3</option>
                                                    <option value="CAR4">ROBOT#4</option>
                                                </select>
                                            </div>
                                            <div style="margin-bottom: 8px;">
                                                <label>é˜Ÿå½¢:</label>
                                                <select id="formationType" class="coord-input">
                                                    <option value="line">ç›´çº¿ç¼–é˜Ÿ</option>
                                                    <option value="Diamond">è±å½¢ç¼–é˜Ÿ</option>
                                                    <option value="square">æ–¹å½¢ç¼–é˜Ÿ</option>
                                                    <option value="custom">è‡ªå®šä¹‰</option>
                                                </select>
                                            </div>
                                            <div class="broadcast-controls">
                                                <button class="broadcast-btn broadcast-on" onclick="startFormation()">å¯åŠ¨ç¼–é˜Ÿ</button>
                                                <button class="broadcast-btn broadcast-off" onclick="stopFormation()">åœæ­¢ç¼–é˜Ÿ</button>
                                            </div>
                                            <div class="broadcast-status" id="formationStatus">
                                                çŠ¶æ€: æœªå¯åŠ¨
                                            </div>
                                        </div>

                                        <div class="control-section">
                                            <h3>é¢„è®¾é˜Ÿå½¢é¢„è§ˆ</h3>
                                            <div style="display: flex; gap: 6px; margin-bottom: 8px;">
                                                <button class="action-btn" onclick="loadFormationPreview('line')" style="font-size: 10px; padding: 4px;">ç›´çº¿</button>
                                                <button class="action-btn" onclick="loadFormationPreview('Diamond')" style="font-size: 10px; padding: 4px;">è±å½¢</button>
                                                <button class="action-btn" onclick="loadFormationPreview('square')" style="font-size: 10px; padding: 4px;">æ–¹å½¢</button>
                                            </div>
                                            
                                            <div class="formation-preview-container">
                                                <canvas id="formationPreviewCanvas"></canvas>
                                                <div class="preview-info" id="formationPreviewInfo">
                                                    é€‰æ‹©é˜Ÿå½¢æŸ¥çœ‹é¢„è§ˆ...
                                                </div>
                                            </div>
                                        </div>

                                        <div class="control-section" id="customFormationSection" style="display: none;">
                                            <h3>è‡ªå®šä¹‰ç¼–é˜Ÿåç§»</h3>
                                            <div style="font-size: 10px; color: #666; margin-bottom: 6px;">
                                                æ ¼å¼: {"CAR2": {"x": 0.7, "y": 0, "yaw": 0}...}
                                            </div>
                                            <textarea id="customOffsets" class="coord-input" rows="3" placeholder='{"CAR2": {"x": -0.7, "y": 0, "yaw": 0}, "CAR3": {"x": -1.4, "y": 0, "yaw": 0}, "CAR4": {"x": -2.1, "y": 0, "yaw": 0}}' style="width: 100%; font-size: 10px;"></textarea>
                                            <button class="action-btn" onclick="setCustomFormation()" style="margin-top: 6px;">è®¾ç½®è‡ªå®šä¹‰ç¼–é˜Ÿ</button>
                                        </div>

                                        <div class="control-section" id="dynamicAdjustSection" style="display: none;">
                                            <h3>åŠ¨æ€è°ƒæ•´</h3>
                                            <div style="font-size: 10px; color: #666; margin-bottom: 6px;">
                                                å®æ—¶è°ƒæ•´é˜Ÿå½¢ï¼ˆä»…é™è·Ÿéšè€…ï¼‰
                                            </div>
                                            <div class="position-control" id="followerInputsContainer">
                                                </div>
                                            <button class="action-btn" onclick="updateFormationOffsets()" style="margin-top: 6px;">æ›´æ–°åç§»é‡</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    </div>
                    <div class="sidebar-right">
                        <div class="right-controls">
                            <div class="collapsible-section">
                                <div class="section-header" onclick="toggleSection('carControlSection')">
                                    å°è½¦æ§åˆ¶
                                </div>
                                <div class="section-content expanded" id="carControlSection">
                                    <div class="control-panel compact-control">
                                        <div class="control-section">
                                            <h3>é€‰æ‹©æ§åˆ¶çš„å°è½¦</h3>
                                            <select id="carSelector" class="coord-input">
                                                <option value="">-- é€‰æ‹©å°è½¦ --</option>
                                            </select>
                                        </div>

                                        <div class="control-section">
                                            <h3>ä½ç½®æ§åˆ¶</h3>
                                            <div class="position-control">
                                                <div>
                                                    <label>Xåæ ‡:</label>
                                                    <input type="number" id="posX" class="coord-input" placeholder="X" step="0.1" min="-6" max="6">
                                                </div>
                                                <div>
                                                    <label>Yåæ ‡:</label>
                                                    <input type="number" id="posY" class="coord-input" placeholder="Y" step="0.1" min="-6" max="6">
                                                </div>
                                                <div style="grid-column: span 2;">
                                                    <label>èˆªå‘è§’:</label>
                                                    <input type="number" id="heading" class="coord-input" placeholder="è§’åº¦" min="0" max="360">
                                                </div>
                                            </div>
                                            <button class="action-btn" onclick="sendPositionCommand()">å¯¼èˆªåˆ°æŒ‡å®šä½ç½®</button>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="collapsible-section">
                                <div class="section-header" onclick="toggleSection('systemControlSection')">
                                    ç³»ç»Ÿæ§åˆ¶
                                </div>
                                <div class="section-content expanded" id="systemControlSection">
                                    <div class="control-panel compact-control">
                                        <div class="control-section">
                                            <h3>å¹¿æ’­æ§åˆ¶</h3>
                                            <div class="broadcast-controls">
                                                <button class="broadcast-btn broadcast-on" onclick="toggleBroadcast(true)" id="broadcastOnBtn">å¼€å¯å¹¿æ’­</button>
                                                <button class="broadcast-btn broadcast-off" onclick="toggleBroadcast(false)" id="broadcastOffBtn">å…³é—­å¹¿æ’­</button>
                                            </div>
                                            <div class="broadcast-status" id="broadcastStatus">
                                                çŠ¶æ€: æœªå¯åŠ¨
                                            </div>
                                        </div>

                                        <div class="control-section">
                                            <h3>é€šä¿¡æ‹“æ‰‘æ§åˆ¶</h3>
                                            <div style="margin-bottom: 8px;">
                                                <div class="topology-matrix">
                                                    <div class="matrix-header"></div>
                                                    <div class="matrix-header">R1</div>
                                                    <div class="matrix-header">R2</div>
                                                    <div class="matrix-header">R3</div>
                                                    <div class="matrix-header">R4</div>

                                                    <div class="matrix-header">R1</div>
                                                    <div class="matrix-cell"><input type="number" id="a11" class="coord-input" value="0" min="0" max="1" readonly style="background: #f0f0f0;"></div>
                                                    <div class="matrix-cell"><input type="number" id="a12" class="coord-input" value="0" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a13" class="coord-input" value="0" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a14" class="coord-input" value="0" min="0" max="1"></div>

                                                    <div class="matrix-header">R2</div>
                                                    <div class="matrix-cell"><input type="number" id="a21" class="coord-input" value="1" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a22" class="coord-input" value="0" min="0" max="1" readonly style="background: #f0f0f0;"></div>
                                                    <div class="matrix-cell"><input type="number" id="a23" class="coord-input" value="0" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a24" class="coord-input" value="0" min="0" max="1"></div>

                                                    <div class="matrix-header">R3</div>
                                                    <div class="matrix-cell"><input type="number" id="a31" class="coord-input" value="1" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a32" class="coord-input" value="0" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a33" class="coord-input" value="0" min="0" max="1" readonly style="background: #f0f0f0;"></div>
                                                    <div class="matrix-cell"><input type="number" id="a34" class="coord-input" value="0" min="0" max="1"></div>

                                                    <div class="matrix-header">R4</div>
                                                    <div class="matrix-cell"><input type="number" id="a41" class="coord-input" value="1" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a42" class="coord-input" value="0" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a43" class="coord-input" value="0" min="0" max="1"></div>
                                                    <div class="matrix-cell"><input type="number" id="a44" class="coord-input" value="0" min="0" max="1" readonly style="background: #f0f0f0;"></div>
                                                </div>
                                                <div style="font-size: 9px; color: #666; text-align: center; margin-top: 3px;">
                                                    A(i,j)=1: Robot#i â†’ Robot#j | å¯¹è§’çº¿å›ºå®šä¸º0
                                                </div>
                                            </div>

                                            <div class="broadcast-controls">
                                                <button class="broadcast-btn broadcast-on" onclick="enableTopology(true)">å¯ç”¨æ‹“æ‰‘</button>
                                                <button class="broadcast-btn broadcast-off" onclick="enableTopology(false)">ç¦ç”¨æ‹“æ‰‘</button>
                                            </div>

                                            <div class="broadcast-status" id="topologyStatus">
                                                çŠ¶æ€: æœªå¯ç”¨
                                            </div>

                                            <div class="visibility-info">
                                                <div style="font-size: 10px; font-weight: bold; margin-bottom: 2px;">å„å°è½¦å¯è§æ€§:</div>
                                                <div id="visibilityInfo" style="font-size: 9px; line-height: 1.2;">
                                                    R#1: R#2, R#3, R#4<br>
                                                    R#2: R#1, R#3, R#4<br>
                                                    R#3: R#1, R#2, R#4<br>
                                                    R#4: R#1, R#2, R#3
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                        </div>
                    </div>
                </div>
            </div>

            <div class="system-status">
                æ›´æ–°æ—¥æœŸ: 2025 | ç³»ç»Ÿè¿è¡Œæ­£å¸¸ | åœ¨çº¿å°è½¦: <span id="onlineCarCount">0</span> å°
            </div>
        </div>

        <div class="coordinate-map">
            <div class="map-header">
                <h1>å®æ—¶ä½ç½®è§‚æµ‹</h1>
                <div id="coordinateRangeDisplay">åæ ‡èŒƒå›´: X[-6, 6], Y[-6, 6] | è§’åº¦: 0Â°=Xè½´æ­£æ–¹å‘, é€†æ—¶é’ˆå¢åŠ </div>
            </div>
            <canvas id="coordinateCanvas"></canvas>
            <div class="performance-info" id="performanceInfo">
                æ›´æ–°é¢‘ç‡: 300ms | å°è½¦: <span id="carCount">0</span>
            </div>
            <div class="angle-indicator">
                è§’åº¦ç³»ç»Ÿ: 0Â°=Xè½´æ­£å‘, é€†æ—¶é’ˆå¢åŠ 
            </div>
        </div>
    </div>

    <div class="car-popup" id="carPopup">
        <button class="popup-close" onclick="closeCarPopup()">&times;</button>
        <h3 id="popupCarId">ROBOT#1</h3>
        <div class="popup-details" id="popupDetails">
            </div>
    </div>

    <script>
        // ==================== å¹¿æ’­é…ç½® ====================
        const BROADCAST_CONFIG = {
            port: 8081,  // ä¸Pythonä»£ç ä¸­çš„BROADCAST_PORTä¿æŒä¸€è‡´
            host: '255.255.255.255'  // å¹¿æ’­åœ°å€
        };

        // ==================== åæ ‡èŒƒå›´é…ç½® ====================
        // åœ¨è¿™é‡Œä¿®æ”¹åæ ‡èŒƒå›´ï¼Œæ–¹ä¾¿åç»­è°ƒæ•´
        const COORDINATE_RANGE = {
            minX: -6,   // Xè½´æœ€å°å€¼
            maxX: 6,    // Xè½´æœ€å¤§å€¼
            minY: -6,   // Yè½´æœ€å°å€¼
            maxY: 6     // Yè½´æœ€å¤§å€¼
        };

        // ==================== é˜Ÿå½¢é¢„è§ˆé…ç½® ====================
        const FORMATION_PREVIEW_CONFIG = {
            canvasWidth: 0, // å°†æ ¹æ®å®¹å™¨å®½åº¦è‡ªåŠ¨è®¾ç½®
            canvasHeight: 150,
            previewRange: 2, // é¢„è§ˆèŒƒå›´ Â±2ç±³
            carSize: 5,      // å°è½¦æ˜¾ç¤ºå¤§å°
            leaderColor: '#e74c3c', // é¢†èˆªè€…é¢œè‰²
            followerColor: '#3498db' // è·Ÿéšè€…é¢œè‰²
        };

        // é˜Ÿå½¢é…ç½®æ•°æ®
        const FORMATION_CONFIGS = {
            'line': {
                'CAR1': {x: 0, y: 0, yaw: 0},
                'CAR2': {x: -0.7, y: 0, yaw: 0},
                'CAR3': {x: -1.4, y: 0, yaw: 0},
                'CAR4': {x: -2.1, y: 0, yaw: 0}
            },
            'Diamond': {
                'CAR1': {x: 0, y: 0, yaw: 0},
                'CAR2': {x: -0.7, y: -0.7, yaw: 0},
                'CAR3': {x: -0.7, y: 0.7, yaw: 0},
                'CAR4': {x: -1.4, y: 0, yaw: 0}
            },
            'square': {
                'CAR1': {x: 0, y: 0, yaw: 0},
                'CAR2': {x: 0, y: -0.7, yaw: 0},
                'CAR3': {x: -0.7, y: -0.7, yaw: 0},
                'CAR4': {x: -0.7, y: 0, yaw: 0}
            }
        };

        // ==================== å…¶ä»–å˜é‡ ====================
        // å°è½¦æ•°æ®
        let cars = [];
        let selectedCarId = null;
        let lastUpdateTime = 0;
        let updateCount = 0;
        let canvas, ctx;
        let carPopup = document.getElementById('carPopup');
        let popupCarId = document.getElementById('popupCarId');
        let popupDetails = document.getElementById('popupDetails');
        let formationPreviewCanvas, formationPreviewCtx;

        // åˆå§‹åŒ–é˜Ÿå½¢é¢„è§ˆç”»å¸ƒ
        function initFormationPreview() {
            formationPreviewCanvas = document.getElementById('formationPreviewCanvas');
            formationPreviewCtx = formationPreviewCanvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸ - å®½åº¦è‡ªé€‚åº”å®¹å™¨
            const containerWidth = formationPreviewCanvas.parentElement.offsetWidth;
            FORMATION_PREVIEW_CONFIG.canvasWidth = containerWidth;
            
            formationPreviewCanvas.width = FORMATION_PREVIEW_CONFIG.canvasWidth;
            formationPreviewCanvas.height = FORMATION_PREVIEW_CONFIG.canvasHeight;
            
            // ç»˜åˆ¶åˆå§‹é¢„è§ˆ
            drawFormationPreview('line', 'CAR1');
        }

        // ç»˜åˆ¶é˜Ÿå½¢é¢„è§ˆ
        function drawFormationPreview(formationType, leaderId) {
            if (!formationPreviewCtx) return;
            
            const ctx = formationPreviewCtx;
            const width = FORMATION_PREVIEW_CONFIG.canvasWidth;
            const height = FORMATION_PREVIEW_CONFIG.canvasHeight;
            const range = FORMATION_PREVIEW_CONFIG.previewRange;
            
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);
            
            // ç»˜åˆ¶èƒŒæ™¯
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);
            
            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1;
            
            // Xè½´
            ctx.beginPath();
            ctx.moveTo(0, height / 2);
            ctx.lineTo(width, height / 2);
            ctx.stroke();
            
            // Yè½´
            ctx.beginPath();
            ctx.moveTo(width / 2, 0);
            ctx.lineTo(width / 2, height);
            ctx.stroke();
            
            // è·å–é˜Ÿå½¢é…ç½®
            const formation = FORMATION_CONFIGS[formationType] || FORMATION_CONFIGS['line'];
            
            // ç»˜åˆ¶å°è½¦
            Object.keys(formation).forEach(carId => {
                const car = formation[carId];
                
                // åæ ‡è½¬æ¢
                const x = (car.x / (range * 2)) * width + width / 2 + 35;
                const y = height / 2 - (car.y / (range * 2)) * height;
                
                // è®¾ç½®é¢œè‰²
                ctx.fillStyle = carId === leaderId ? 
                    FORMATION_PREVIEW_CONFIG.leaderColor : 
                    FORMATION_PREVIEW_CONFIG.followerColor;
                
                // ç»˜åˆ¶å°è½¦
                ctx.beginPath();
                ctx.arc(x, y, FORMATION_PREVIEW_CONFIG.carSize, 0, Math.PI * 2);
                ctx.fill();
                
                // ç»˜åˆ¶å°è½¦ID (è¿™é‡Œåœ¨é¢„è§ˆå›¾ä¸­ä½¿ç”¨ R1, R2 å½¢å¼ä»¥èŠ‚çœç©ºé—´)
                ctx.fillStyle = carId === leaderId ? '#fff' : '#2c3e50';
                ctx.font = 'bold 7px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(carId.replace('CAR', 'R'), x, y);
                
                // å¦‚æœæ˜¯é¢†èˆªè€…ï¼Œç»˜åˆ¶ç‰¹æ®Šæ ‡è®°
                if (carId === leaderId) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.arc(x, y, FORMATION_PREVIEW_CONFIG.carSize + 1, 0, Math.PI * 2);
                    ctx.stroke();
                }
            });
            
            // æ›´æ–°é¢„è§ˆä¿¡æ¯
            document.getElementById('formationPreviewInfo').textContent = 
                `${getFormationName(formationType)}é˜Ÿå½¢ - é¢†èˆªè€…: ${leaderId.replace('CAR', 'ROBOT#')}`;
        }

        // è·å–é˜Ÿå½¢åç§°
        function getFormationName(formationType) {
            const names = {
                'line': 'ç›´çº¿',
                'Diamond': 'è±å½¢',
                'square': 'æ–¹å½¢',
                'custom': 'è‡ªå®šä¹‰'
            };
            return names[formationType] || formationType;
        }

        // ä¿®æ”¹loadFormationPreviewå‡½æ•°ï¼Œæ·»åŠ é¢„è§ˆç»˜åˆ¶
        async function loadFormationPreview(formationType) {
            try {
                const response = await fetch('/api/formation/configs');
                const result = await response.json();

                if (result.success && result.formation_configs[formationType]) {
                    const config = result.formation_configs[formationType];
                    
                    // ç»˜åˆ¶é˜Ÿå½¢é¢„è§ˆ
                    const leaderId = document.getElementById('leaderSelector').value;
                    drawFormationPreview(formationType, leaderId);

                    // å¦‚æœæ˜¯è‡ªå®šä¹‰æ¨¡å¼ï¼Œå¡«å……åˆ°æ–‡æœ¬æ¡†
                    if (formationType !== 'custom') {
                        document.getElementById('customOffsets').value = JSON.stringify(config, null, 2);
                    }
                }
            } catch (error) {
                console.error('åŠ è½½é˜Ÿå½¢é¢„è§ˆå¤±è´¥:', error);
            }
        }

        // è®¡ç®—åæ ‡èŒƒå›´æ˜¾ç¤ºæ–‡æœ¬
        function getCoordinateRangeText() {
            return `åæ ‡èŒƒå›´: X[${COORDINATE_RANGE.minX}, ${COORDINATE_RANGE.maxX}], Y[${COORDINATE_RANGE.minY}, ${COORDINATE_RANGE.maxY}] | è§’åº¦: 0Â°=Xè½´æ­£æ–¹å‘, é€†æ—¶é’ˆå¢åŠ `;
        }

        // ç½‘ç»œçŠ¶æ€æ£€æŸ¥
        function checkNetworkStatus() {
            const statusElement = document.getElementById('broadcastStatus');
            statusElement.innerHTML = `çŠ¶æ€: æœªå¯åŠ¨ | å¹¿æ’­ç«¯å£: ${BROADCAST_CONFIG.port}`;

            console.log('ğŸ“¡ å¹¿æ’­é…ç½®:', BROADCAST_CONFIG);
            console.log('ğŸŒ ç¡®ä¿å°è½¦ç›‘å¬ç«¯å£:', BROADCAST_CONFIG.port);
        }

        // æŠ˜å é¢æ¿æ§åˆ¶
        function toggleSection(sectionId) {
            const section = document.getElementById(sectionId);
            const header = section.previousElementSibling;

            section.classList.toggle('expanded');
            header.classList.toggle('collapsed');
        }

        // åˆå§‹åŒ–åæ ‡å›¾
        function initCoordinateMap() {
            canvas = document.getElementById('coordinateCanvas');
            ctx = canvas.getContext('2d');

            // æ›´æ–°åæ ‡èŒƒå›´æ˜¾ç¤º
            document.getElementById('coordinateRangeDisplay').textContent = getCoordinateRangeText();

            // è®¾ç½®Canvaså°ºå¯¸
            function resizeCanvas() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                drawCoordinateSystem();
            }

            // åˆå§‹è°ƒæ•´å°ºå¯¸
            resizeCanvas();

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', resizeCanvas);
        }

        // ç»˜åˆ¶åæ ‡ç³»ç»Ÿ
        function drawCoordinateSystem() {
            const width = canvas.width;
            const height = canvas.height;

            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶èƒŒæ™¯
            ctx.fillStyle = '#f8f9fa';
            ctx.fillRect(0, 0, width, height);

            // è®¡ç®—åæ ‡èŒƒå›´
            const rangeX = COORDINATE_RANGE.maxX - COORDINATE_RANGE.minX;
            const rangeY = COORDINATE_RANGE.maxY - COORDINATE_RANGE.minY;

            // ç¡®ä¿æ¨ªçºµåæ ‡æ¯”ä¾‹1:1
            const scaleX = width / rangeX;
            const scaleY = height / rangeY;
            const scale = Math.min(scaleX, scaleY); // å–è¾ƒå°çš„æ¯”ä¾‹ç¡®ä¿å†…å®¹å®Œå…¨æ˜¾ç¤º

            // è®¡ç®—å±…ä¸­åç§»é‡
            const offsetX = (width - rangeX * scale) / 2;
            const offsetY = (height - rangeY * scale) / 2;

            // ç»˜åˆ¶ç½‘æ ¼
            ctx.strokeStyle = '#e9ecef';
            ctx.lineWidth = 1;

            const gridSize = 1; // ç½‘æ ¼å¤§å°ä¸º1ä¸ªå•ä½
            for (let x = COORDINATE_RANGE.minX; x <= COORDINATE_RANGE.maxX; x += gridSize) {
                const pixelX = coordinateToPixelX(x);
                ctx.beginPath();
                ctx.moveTo(pixelX, offsetY);
                ctx.lineTo(pixelX, height - offsetY);
                ctx.stroke();
            }

            for (let y = COORDINATE_RANGE.minY; y <= COORDINATE_RANGE.maxY; y += gridSize) {
                const pixelY = coordinateToPixelY(y);
                ctx.beginPath();
                ctx.moveTo(offsetX, pixelY);
                ctx.lineTo(width - offsetX, pixelY);
                ctx.stroke();
            }

            // ç»˜åˆ¶åæ ‡è½´
            ctx.strokeStyle = '#495057';
            ctx.lineWidth = 2;

            // Xè½´
            const zeroY = coordinateToPixelY(0);
            ctx.beginPath();
            ctx.moveTo(offsetX, zeroY);
            ctx.lineTo(width - offsetX, zeroY);
            ctx.stroke();

            // Yè½´
            const zeroX = coordinateToPixelX(0);
            ctx.beginPath();
            ctx.moveTo(zeroX, offsetY);
            ctx.lineTo(zeroX, height - offsetY);
            ctx.stroke();

            // ç»˜åˆ¶åæ ‡åˆ»åº¦
            ctx.fillStyle = '#495057';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Xè½´åˆ»åº¦ï¼ˆæ¯2ä¸ªå•ä½ä¸€ä¸ªåˆ»åº¦ï¼‰
            for (let x = COORDINATE_RANGE.minX; x <= COORDINATE_RANGE.maxX; x += 2) {
                const pixelX = coordinateToPixelX(x);
                ctx.beginPath();
                ctx.moveTo(pixelX, zeroY - 5);
                ctx.lineTo(pixelX, zeroY + 5);
                ctx.stroke();

                ctx.fillText(x.toString(), pixelX, zeroY + 10);
            }

            // Yè½´åˆ»åº¦
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let y = COORDINATE_RANGE.minY; y <= COORDINATE_RANGE.maxY; y += 2) {
                const pixelY = coordinateToPixelY(y);
                ctx.beginPath();
                ctx.moveTo(zeroX - 5, pixelY);
                ctx.lineTo(zeroX + 5, pixelY);
                ctx.stroke();

                ctx.fillText(y.toString(), zeroX - 10, pixelY);
            }

            // ç»˜åˆ¶åæ ‡åŸç‚¹
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.arc(zeroX, zeroY, 4, 0, Math.PI * 2);
            ctx.fill();

            // ç»˜åˆ¶åæ ‡è½´æ ‡ç­¾
            ctx.fillStyle = '#2c3e50';
            ctx.font = '13px Arial';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'top';
            ctx.fillText('Y', zeroX - 15, offsetY);

            ctx.textAlign = 'left';
            ctx.textBaseline = 'bottom';
            ctx.fillText('X', width - offsetX, zeroY - 10);

            // ç»˜åˆ¶è§’åº¦æŒ‡ç¤ºå™¨
            drawAngleIndicators();
        }

        // ç»˜åˆ¶è§’åº¦æŒ‡ç¤ºå™¨
        function drawAngleIndicators() {
            const width = canvas.width;
            const height = canvas.height;

            // è®¡ç®—åæ ‡èŒƒå›´
            const rangeX = COORDINATE_RANGE.maxX - COORDINATE_RANGE.minX;
            const rangeY = COORDINATE_RANGE.maxY - COORDINATE_RANGE.minY;
            const scaleX = width / rangeX;
            const scaleY = height / rangeY;
            const scale = Math.min(scaleX, scaleY);

            // è®¡ç®—å±…ä¸­åç§»é‡
            const offsetX = (width - rangeX * scale) / 2;
            const offsetY = (height - rangeY * scale) / 2;

            const centerX = coordinateToPixelX(0);
            const centerY = coordinateToPixelY(0);
            const radius = Math.min(width - offsetX * 2, height - offsetY * 2) * 0.35;

            ctx.strokeStyle = '#bdc3c7';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 3]);

            // ç»˜åˆ¶è§’åº¦åœ†
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.stroke();

            ctx.setLineDash([]);

            // ç»˜åˆ¶è§’åº¦æ ‡è®°
            ctx.fillStyle = '#7f8c8d';
            ctx.font = '11px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let angle = 0; angle < 360; angle += 30) {
                const rad = angle * Math.PI / 180;
                // è°ƒæ•´Yè½´æ–¹å‘ï¼šCanvas Yè½´å‘ä¸‹ï¼Œæ­¤å¤„ç”¨"-sin(rad)"ä½¿è§’åº¦é€†æ—¶é’ˆæ—¶90Â°æŒ‡å‘æ­£ä¸Šæ–¹
                const x = centerX + radius * Math.cos(rad);
                const y = centerY - radius * Math.sin(rad);

                // ç»˜åˆ¶è§’åº¦çº¿
                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.lineTo(x, y);
                ctx.stroke();

                // ç»˜åˆ¶è§’åº¦æ–‡æœ¬ï¼ˆç¡®ä¿åœ¨åœ†å¤–ï¼‰
                const textRadius = radius + 20;
                const textX = centerX + textRadius * Math.cos(rad);
                const textY = centerY - textRadius * Math.sin(rad);
                ctx.fillText(angle + 'Â°', textX, textY);
            }

            // ç‰¹åˆ«æ ‡æ³¨0åº¦æ–¹å‘ï¼ˆXè½´æ­£æ–¹å‘ï¼‰
            ctx.fillStyle = '#e74c3c';
            const zeroTextX = centerX + (radius + 25) * Math.cos(0);
            const zeroTextY = centerY - (radius + 25) * Math.sin(0);
            ctx.fillText('0Â°', zeroTextX, zeroTextY);
        }

        // ==================== åæ ‡è½¬æ¢å‡½æ•° ====================
        // å°†åæ ‡Xè½¬æ¢ä¸ºåƒç´ Xï¼ˆä¿æŒ1:1æ¯”ä¾‹ï¼Œå±…ä¸­æ˜¾ç¤ºï¼‰
        function coordinateToPixelX(x) {
            const width = canvas.width;
            const height = canvas.height;
            
            // è®¡ç®—åæ ‡èŒƒå›´
            const rangeX = COORDINATE_RANGE.maxX - COORDINATE_RANGE.minX;
            const rangeY = COORDINATE_RANGE.maxY - COORDINATE_RANGE.minY;
            
            // ç¡®ä¿æ¨ªçºµåæ ‡æ¯”ä¾‹1:1
            const scaleX = width / rangeX;
            const scaleY = height / rangeY;
            const scale = Math.min(scaleX, scaleY); // å–è¾ƒå°çš„æ¯”ä¾‹ç¡®ä¿å†…å®¹å®Œå…¨æ˜¾ç¤º
            
            // è®¡ç®—å±…ä¸­åç§»é‡
            const offsetX = (width - rangeX * scale) / 2;
            
            return offsetX + (x - COORDINATE_RANGE.minX) * scale;
        }

        // å°†åæ ‡Yè½¬æ¢ä¸ºåƒç´ Yï¼ˆä¿æŒ1:1æ¯”ä¾‹ï¼Œå±…ä¸­æ˜¾ç¤ºï¼‰
        function coordinateToPixelY(y) {
            const width = canvas.width;
            const height = canvas.height;
            
            // è®¡ç®—åæ ‡èŒƒå›´
            const rangeX = COORDINATE_RANGE.maxX - COORDINATE_RANGE.minX;
            const rangeY = COORDINATE_RANGE.maxY - COORDINATE_RANGE.minY;
            
            // ç¡®ä¿æ¨ªçºµåæ ‡æ¯”ä¾‹1:1
            const scaleX = width / rangeX;
            const scaleY = height / rangeY;
            const scale = Math.min(scaleX, scaleY); // å–è¾ƒå°çš„æ¯”ä¾‹ç¡®ä¿å†…å®¹å®Œå…¨æ˜¾ç¤º
            
            // è®¡ç®—å±…ä¸­åç§»é‡
            const offsetY = (height - rangeY * scale) / 2;
            
            return height - offsetY - (y - COORDINATE_RANGE.minY) * scale;
        }

        // ==================== å…¶ä»–å‡½æ•°ä¿æŒä¸å˜ ====================
        // ç»˜åˆ¶å°è½¦
        function drawCars() {
            cars.forEach(car => {
                if (!car.connected) return;

                const pixelX = coordinateToPixelX(car.position.x);
                const pixelY = coordinateToPixelY(car.position.y);

                // ç»˜åˆ¶å°è½¦æŒ‡é’ˆ
                drawCarPointer(pixelX, pixelY, car.heading, car.id, car.battery, car.velocity);
            });
        }

        // ç»˜åˆ¶å°è½¦æŒ‡é’ˆï¼ˆä¿æŒä¸å˜ï¼‰
        function drawCarPointer(x, y, heading, carId, battery, velocity) {
            const pointerSize = 18;
            const pointerLength = 25;

            // ä¿å­˜å½“å‰ä¸Šä¸‹æ–‡çŠ¶æ€
            ctx.save();

            // ç§»åŠ¨åˆ°å°è½¦ä½ç½®å¹¶æ—‹è½¬ç”»å¸ƒï¼ˆ-heading é€‚é… Canvas é¡ºæ—¶é’ˆæ—‹è½¬ä¸ºæ­£çš„ç‰¹æ€§ï¼Œå®ç°é€†æ—¶é’ˆè§’åº¦é€’å¢ï¼‰
            ctx.translate(x, y);
            ctx.rotate(-heading * Math.PI / 180);

            // ç»˜åˆ¶æŒ‡é’ˆä¸»ä½“ï¼ˆé¡¶ç‚¹æŒ‡å‘ X è½´æ­£æ–¹å‘ï¼Œæ—‹è½¬ååŒ¹é…é€†æ—¶é’ˆè§’åº¦ï¼‰
            ctx.fillStyle = selectedCarId === carId ? '#e74c3c' : '#3498db';
            ctx.beginPath();
            ctx.moveTo(pointerLength / 2, 0); // é¡¶ç‚¹åœ¨ X è½´æ­£æ–¹å‘
            ctx.lineTo(-pointerLength / 2, -pointerSize / 2); // å·¦ä¸‹ç‚¹
            ctx.lineTo(-pointerLength / 2, pointerSize / 2); // å³ä¸Šç‚¹
            ctx.closePath();
            ctx.fill();

            // ç»˜åˆ¶æŒ‡é’ˆä¸­å¿ƒåœ†
            ctx.fillStyle = selectedCarId === carId ? '#c0392b' : '#2980b9';
            ctx.beginPath();
            ctx.arc(0, 0, 6, 0, Math.PI * 2);
            ctx.fill();

            // æ¢å¤ä¸Šä¸‹æ–‡çŠ¶æ€
            ctx.restore();

            // ç»˜åˆ¶å°è½¦ID (æ›¿æ¢æ˜¾ç¤º CAR ä¸º R#)
            const displayId = carId.replace('CAR', 'R#');
            ctx.fillStyle = selectedCarId === carId ? '#e74c3c' : '#2c3e50';
            ctx.font = 'bold 13px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'bottom';
            ctx.fillText(displayId, x, y - pointerLength/2 - 5);

            // ç»˜åˆ¶ç”µæ± çŠ¶æ€æŒ‡ç¤º
            const batteryWidth = 25;
            const batteryHeight = 7;
            const batteryX = x - batteryWidth/2;
            const batteryY = y + pointerLength/2 + 8;

            // ç”µæ± å¤–å£³
            ctx.strokeStyle = '#95a5a6';
            ctx.lineWidth = 1;
            ctx.strokeRect(batteryX, batteryY, batteryWidth, batteryHeight);

            // ç”µæ± æ­£æ
            ctx.fillStyle = '#95a5a6';
            ctx.fillRect(batteryX + batteryWidth, batteryY + batteryHeight/4, 2, batteryHeight/2);

            // ç”µæ± ç”µé‡
            const batteryLevel = Math.min(100, Math.max(0, (battery - 10) / 2.6 * 100));
            ctx.fillStyle = batteryLevel < 20 ? '#e74c3c' : '#2ecc71';
            ctx.fillRect(batteryX + 1, batteryY + 1, (batteryWidth - 2) * batteryLevel / 100, batteryHeight - 2);

            // ç»˜åˆ¶çº¿æ€§é€Ÿåº¦çŸ¢é‡
            if (velocity && (velocity.vx !== 0 || velocity.vy !== 0)) {
                const speedScale = 40; // é€Ÿåº¦çŸ¢é‡ç¼©æ”¾å› å­
                const vx = velocity.vx * speedScale;
                const vy = -velocity.vy * speedScale; // Yè½´æ–¹å‘åè½¬

                // ç»˜åˆ¶çº¿æ€§é€Ÿåº¦çŸ¢é‡
                ctx.strokeStyle = '#e74c3c';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + vx, y + vy);
                ctx.stroke();

                // ç»˜åˆ¶é€Ÿåº¦ç®­å¤´
                const arrowSize = 5;
                const angle = Math.atan2(vy, vx);
                ctx.beginPath();
                ctx.moveTo(x + vx, y + vy);
                ctx.lineTo(x + vx - arrowSize * Math.cos(angle - Math.PI/6), y + vy - arrowSize * Math.sin(angle - Math.PI/6));
                ctx.moveTo(x + vx, y + vy);
                ctx.lineTo(x + vx - arrowSize * Math.cos(angle + Math.PI/6), y + vy - arrowSize * Math.sin(angle + Math.PI/6));
                ctx.stroke();
            }
        }

        // ç²¾ç®€ç‰ˆæ•°æ®è§£æå‡½æ•°
        function parseCompactCarData(carData) {
            // æ£€æŸ¥æ˜¯å¦ä¸ºç²¾ç®€æ ¼å¼
            if (carData.i !== undefined) {
                // ç²¾ç®€æ ¼å¼è§£æ
                return {
                    id: carData.i,
                    mac_address: carData.ma || `CAR_${carData.i}`,
                    position: {
                        x: Array.isArray(carData.p) ? carData.p[0] : (carData.position?.x || 0),
                        y: Array.isArray(carData.p) ? carData.p[1] : (carData.position?.y || 0)
                    },
                    heading: carData.h || carData.heading || 0,
                    battery: carData.b || carData.battery || 0,
                    velocity: {
                        vx: Array.isArray(carData.v) ? carData.v[0] : (carData.velocity?.vx || 0),
                        vy: Array.isArray(carData.v) ? carData.v[1] : (carData.velocity?.vy || 0),
                        vz: Array.isArray(carData.v) ? carData.v[2] : (carData.velocity?.vz || 0)
                    },
                    speed: carData.s || carData.speed || 0,
                    connected: carData.c !== undefined ? carData.c : carData.connected,
                    status: carData.st || carData.status || "æ­£å¸¸",
                    last_update: carData.lu || carData.last_update || Date.now(),
                    update_count: carData.uc || carData.update_count || 0
                };
            } else {
                // å®Œæ•´æ ¼å¼è§£æ
                return carData;
            }
        }

        // è·å–å°è½¦æ•°æ®
        async function fetchCars() {
            try {
                const startTime = performance.now();
                const response = await fetch('/api/cars');
                let carsData = await response.json();
                const endTime = performance.now();

                // æ ‡å‡†åŒ–å°è½¦æ•°æ®ï¼ˆæ”¯æŒç²¾ç®€å’Œå®Œæ•´æ ¼å¼ï¼‰
                cars = Array.isArray(carsData) ? carsData.map(parseCompactCarData) : [];

                updateCarList();
                drawCoordinateSystem();
                drawCars();
                updateCarSelector();
                updatePerformanceInfo(cars.length, endTime - startTime);

            } catch (error) {
                console.error('è·å–å°è½¦æ•°æ®å¤±è´¥:', error);
                updatePerformanceInfo(0, 0, true);
            }
        }

        // æ›´æ–°æ€§èƒ½ä¿¡æ¯
        function updatePerformanceInfo(carCount, fetchTime, isError = false) {
            const performanceInfo = document.getElementById('performanceInfo');
            const carCountElement = document.getElementById('carCount');
            const onlineCarCountElement = document.getElementById('onlineCarCount');

            updateCount++;
            carCountElement.textContent = carCount;

            // æ›´æ–°åœ¨çº¿å°è½¦æ•°é‡
            const onlineCount = cars.filter(car => car.connected).length;
            onlineCarCountElement.textContent = onlineCount;

            if (isError) {
                performanceInfo.innerHTML = `âŒ è¿æ¥é”™è¯¯ | å°è½¦: ${carCount}`;
                performanceInfo.style.background = '#fed7d7';
            } else {
                performanceInfo.innerHTML =
                    `æ›´æ–°é¢‘ç‡: 300ms | å°è½¦: ${carCount} | å“åº”: ${fetchTime.toFixed(1)}ms`;
                performanceInfo.style.background = '#c6f6d5';
            }
        }

        // æ›´æ–°å°è½¦åˆ—è¡¨ - ä¿®å¤é€Ÿåº¦æ˜¾ç¤º
        function updateCarList() {
            const carList = document.getElementById('carList');

            if (cars.length === 0) {
                carList.innerHTML = '<div class="no-cars" style="text-align: center; color: #718096; padding: 15px;">ç­‰å¾…å°è½¦è¿æ¥...</div>';
                return;
            }

            carList.innerHTML = cars.map(car => `
                <div class="car-item ${car.connected ? '' : 'disconnected'} ${car.id === selectedCarId ? 'selected' : ''}" onclick="selectCar('${car.id}')">
                    <div class="car-header">
                        <div class="car-id"> ${car.id.replace('CAR', 'ROBOT#')}</div>
                        <div class="car-status ${car.connected ? 'status-connected' : 'status-disconnected'}">
                            ${car.connected ? 'åœ¨çº¿' : 'ç¦»çº¿'}
                        </div>
                    </div>
                    <div class="car-details">
                        <div class="detail-item">
                            <span class="detail-label">ä½ç½®</span>
                            <span class="detail-value">(${car.position.x.toFixed(2)}, ${car.position.y.toFixed(2)})</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">èˆªå‘è§’</span>
                            <span class="detail-value">${car.heading.toFixed(1)}Â°</span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">é€Ÿåº¦</span>
                            <span class="detail-value">
                                ${car.speed.toFixed(3)} mm/s
                                <div class="speed-info">
                                    <div class="velocity-components">
                                        <span>Vx: ${car.velocity.vx.toFixed(3)}</span>
                                        <span>Vy: ${car.velocity.vy.toFixed(3)}</span>
                                        <span>Vz: ${car.velocity.vz.toFixed(3)}</span>
                                    </div>
                                </div>
                            </span>
                        </div>
                        <div class="detail-item">
                            <span class="detail-label">ç”µå‹</span>
                            <span class="detail-value">
                                <div class="battery">
                                    <div class="battery-level">
                                        <div class="battery-fill ${car.battery < 11 ? 'battery-low' : ''}"
                                             style="width: ${Math.min(100, Math.max(0, (car.battery - 10) / 2.6 * 100))}%"></div>
                                    </div>
                                    ${car.battery.toFixed(1)}V
                                </div>
                            </span>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // æ›´æ–°å°è½¦é€‰æ‹©å™¨
        function updateCarSelector() {
            const selector = document.getElementById('carSelector');
            const currentSelection = selector.value;

            // é€‰é¡¹çš„ Value ä¿æŒä¸å˜ (CAR1)ï¼Œåªæ”¹å˜æ˜¾ç¤ºæ–‡æœ¬ (ROBOT#1)
            selector.innerHTML = '<option value="">-- é€‰æ‹©å°è½¦ --</option>' +
                cars.filter(car => car.connected).map(car =>
                    `<option value="${car.id}" ${car.id === currentSelection ? 'selected' : ''}>${car.id.replace('CAR', 'ROBOT#')}</option>`
                ).join('');

            if (!currentSelection && cars.length > 0) {
                const firstConnected = cars.find(car => car.connected);
                if (firstConnected) {
                    selector.value = firstConnected.id;
                    selectedCarId = firstConnected.id;
                }
            }
        }

        // é€‰æ‹©å°è½¦
        function selectCar(carId) {
            selectedCarId = carId;
            document.getElementById('carSelector').value = carId;

            // é«˜äº®æ˜¾ç¤ºé€‰ä¸­çš„å°è½¦
            document.querySelectorAll('.car-item').forEach(item => {
                // æ›´æ–°åŒ¹é…é€»è¾‘ä»¥é€‚åº” ROBOT#
                item.classList.toggle('selected', item.querySelector('.car-id').textContent.includes(carId.replace('CAR', 'ROBOT#')));
            });

            // é‡ç»˜åæ ‡å›¾ä»¥çªå‡ºæ˜¾ç¤ºé€‰ä¸­çš„å°è½¦
            drawCoordinateSystem();
            drawCars();
        }

        // å¹¿æ’­æ§åˆ¶å‡½æ•° - ä¿®æ”¹ç‰ˆæœ¬
        async function toggleBroadcast(enable) {
            try {
                const response = await fetch('/api/broadcast', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enable: enable
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message + ' - ç«¯å£: ' + BROADCAST_CONFIG.port, 'success');
                    updateBroadcastStatus(enable);
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('æ§åˆ¶å¹¿æ’­å¤±è´¥:', error);
                showMessage('æ§åˆ¶å¹¿æ’­å¤±è´¥ - è¯·æ£€æŸ¥æœåŠ¡å™¨è¿æ¥', 'error');
            }
        }

        // æ›´æ–°å¹¿æ’­çŠ¶æ€æ˜¾ç¤º - ä¿®æ”¹ç‰ˆæœ¬
        function updateBroadcastStatus(enable) {
            const statusElement = document.getElementById('broadcastStatus');
            const onBtn = document.getElementById('broadcastOnBtn');
            const offBtn = document.getElementById('broadcastOffBtn');

            if (enable) {
                statusElement.innerHTML = `çŠ¶æ€: <span style="color: #48bb78;">å¹¿æ’­ä¸­</span> | ç«¯å£: ${BROADCAST_CONFIG.port}`;
                onBtn.classList.remove('inactive');
                offBtn.classList.add('inactive');
            } else {
                statusElement.innerHTML = `çŠ¶æ€: <span style="color: #f56565;">å·²åœæ­¢</span> | ç«¯å£: ${BROADCAST_CONFIG.port}`;
                onBtn.classList.add('inactive');
                offBtn.classList.remove('inactive');
            }
        }

        // è·å–å¹¿æ’­çŠ¶æ€
        async function getBroadcastStatus() {
            try {
                const response = await fetch('/api/broadcast/status');
                const status = await response.json();
                updateBroadcastStatus(status.broadcast_enabled);
            } catch (error) {
                console.error('è·å–å¹¿æ’­çŠ¶æ€å¤±è´¥:', error);
            }
        }

        // å‘é€ä½ç½®æ§åˆ¶æŒ‡ä»¤
        async function sendPositionCommand() {
            if (!selectedCarId) {
                alert('è¯·å…ˆé€‰æ‹©è¦æ§åˆ¶çš„å°è½¦');
                return;
            }

            const posX = parseFloat(document.getElementById('posX').value);
            const posY = parseFloat(document.getElementById('posY').value);
            const heading = document.getElementById('heading').value ?
                parseInt(document.getElementById('heading').value) : undefined;

            if (isNaN(posX) || isNaN(posY)) {
                alert('è¯·è¾“å…¥æœ‰æ•ˆçš„åæ ‡å€¼');
                return;
            }

            try {
                const response = await fetch('/api/control_position', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        car_id: selectedCarId,
                        position: { x: posX, y: posY },
                        heading: heading
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('å‘é€ä½ç½®æŒ‡ä»¤å¤±è´¥:', error);
                showMessage('å‘é€ä½ç½®æŒ‡ä»¤å¤±è´¥', 'error');
            }
        }

        // æ‹“æ‰‘æ§åˆ¶å‡½æ•°
        async function setTopology() {
            const topology = [
                [0, parseInt(document.getElementById('a12').value), parseInt(document.getElementById('a13').value), parseInt(document.getElementById('a14').value)],
                [parseInt(document.getElementById('a21').value), 0, parseInt(document.getElementById('a23').value), parseInt(document.getElementById('a24').value)],
                [parseInt(document.getElementById('a31').value), parseInt(document.getElementById('a32').value), 0, parseInt(document.getElementById('a34').value)],
                [parseInt(document.getElementById('a41').value), parseInt(document.getElementById('a42').value), parseInt(document.getElementById('a43').value), 0]
            ];

            try {
                const response = await fetch('/api/topology', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        topology: topology,
                        enable: true
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    updateTopologyStatus(true);
                    updateVisibilityInfo(); // æ›´æ–°å¯è§æ€§ä¿¡æ¯
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('è®¾ç½®æ‹“æ‰‘å¤±è´¥:', error);
                showMessage('è®¾ç½®æ‹“æ‰‘å¤±è´¥', 'error');
            }
        }

        async function enableTopology(enable) {
            try {
                const response = await fetch('/api/topology/toggle', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        enable: enable
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    updateTopologyStatus(enable);

                    // å¦‚æœå¯ç”¨æ‹“æ‰‘ï¼ŒåŒæ—¶è®¾ç½®æ‹“æ‰‘çŸ©é˜µ
                    if (enable) {
                        setTopology();
                    } else {
                        updateVisibilityInfo(); // ç¦ç”¨æ—¶ä¹Ÿæ›´æ–°å¯è§æ€§ä¿¡æ¯
                    }
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('åˆ‡æ¢æ‹“æ‰‘çŠ¶æ€å¤±è´¥:', error);
                showMessage('åˆ‡æ¢æ‹“æ‰‘çŠ¶æ€å¤±è´¥', 'error');
            }
        }

        async function getTopologyStatus() {
            try {
                const response = await fetch('/api/topology/status');
                const status = await response.json();
                updateTopologyStatus(status.topology_enabled);

                // æ›´æ–°çŸ©é˜µæ˜¾ç¤º
                if (status.topology) {
                    document.getElementById('a12').value = status.topology[0][1];
                    document.getElementById('a13').value = status.topology[0][2];
                    document.getElementById('a14').value = status.topology[0][3];
                    document.getElementById('a21').value = status.topology[1][0];
                    document.getElementById('a23').value = status.topology[1][2];
                    document.getElementById('a24').value = status.topology[1][3];
                    document.getElementById('a31').value = status.topology[2][0];
                    document.getElementById('a32').value = status.topology[2][1];
                    document.getElementById('a34').value = status.topology[2][3];
                    document.getElementById('a41').value = status.topology[3][0];
                    document.getElementById('a42').value = status.topology[3][1];
                    document.getElementById('a43').value = status.topology[3][2];
                }

                updateVisibilityInfo(); // æ›´æ–°å¯è§æ€§ä¿¡æ¯
            } catch (error) {
                console.error('è·å–æ‹“æ‰‘çŠ¶æ€å¤±è´¥:', error);
            }
        }

        function updateTopologyStatus(enable) {
            const statusElement = document.getElementById('topologyStatus');
            if (enable) {
                statusElement.innerHTML = 'çŠ¶æ€: <span style="color: #48bb78;">å·²å¯ç”¨</span>';
            } else {
                statusElement.innerHTML = 'çŠ¶æ€: <span style="color: #f56565;">æœªå¯ç”¨</span>';
            }
        }

        // æ›´æ–°å¯è§æ€§ä¿¡æ¯
        async function updateVisibilityInfo() {
            try {
                const visibilityInfo = document.getElementById('visibilityInfo');
                let html = '';

                for (let carId of ['CAR1', 'CAR2', 'CAR3', 'CAR4']) {
                    const response = await fetch(`/api/topology/visible/${carId}`);
                    const data = await response.json();
                    // åœ¨æ˜¾ç¤ºæ—¶æ›¿æ¢åç§°
                    const displayId = carId.replace('CAR', 'R#');
                    const visibleCars = data.visible_cars.map(c => c.replace('CAR', 'R#')).join(', ');
                    html += `${displayId}: ${visibleCars}<br>`;
                }

                visibilityInfo.innerHTML = html;
            } catch (error) {
                console.error('è·å–å¯è§æ€§ä¿¡æ¯å¤±è´¥:', error);
            }
        }

        // æ˜¾ç¤ºæ¶ˆæ¯
        function showMessage(message, type) {
            // åˆ›å»ºä¸´æ—¶æ¶ˆæ¯æç¤º
            const messageDiv = document.createElement('div');
            messageDiv.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                padding: 8px 16px;
                background: ${type === 'success' ? '#48bb78' : '#f56565'};
                color: white;
                border-radius: 5px;
                z-index: 10000;
                font-weight: bold;
                box-shadow: 0 4px 6px rgba(0,0,0,0.1);
                font-size: 13px;
            `;
            messageDiv.textContent = message;
            document.body.appendChild(messageDiv);

            setTimeout(() => {
                document.body.removeChild(messageDiv);
            }, 3000);
        }

        // æ˜¾ç¤ºå°è½¦è¯¦æƒ…å¼¹çª— - ä¿®å¤é€Ÿåº¦æ˜¾ç¤º
        function showCarPopup(carId, x, y) {
            const car = cars.find(c => c.id === carId);
            if (!car) return;

            // æ›¿æ¢æ ‡é¢˜ä¸­çš„æ˜¾ç¤º
            popupCarId.textContent = carId.replace('CAR', 'ROBOT#');
            popupDetails.innerHTML = `
                <div class="detail-item">
                    <span class="detail-label">ä½ç½®</span>
                    <span class="detail-value">(${car.position.x.toFixed(2)}, ${car.position.y.toFixed(2)})</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">èˆªå‘è§’</span>
                    <span class="detail-value">${car.heading.toFixed(1)}Â°</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">é€Ÿåº¦</span>
                    <span class="detail-value">
                        ${car.speed.toFixed(3)} m/s
                        <div class="speed-info">
                            <div>Vx: ${car.velocity.vx.toFixed(3)} m/s</div>
                            <div>Vy: ${car.velocity.vy.toFixed(3)} m/s</div>
                            <div>Vz: ${car.velocity.vz.toFixed(3)} rad/s</div>
                        </div>
                    </span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">ç”µå‹</span>
                    <span class="detail-value">${car.battery.toFixed(1)}V</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">çŠ¶æ€</span>
                    <span class="detail-value">${car.status}</span>
                </div>
                <div class="detail-item">
                    <span class="detail-label">MACåœ°å€</span>
                    <span class="detail-value">${car.mac_address}</span>
                </div>
            `;

            carPopup.style.display = 'block';
            carPopup.style.left = `${x + 10}px`;
            carPopup.style.top = `${y + 10}px`;
        }

        // ç”Ÿæˆè·Ÿéšè€…åç§»é‡è¾“å…¥æ¡†
        function generateFollowerInputs(leaderId) {
            const allCars = ['CAR1', 'CAR2', 'CAR3', 'CAR4'];
            const followers = allCars.filter(carId => carId !== leaderId);

            let html = '';
            followers.forEach(carId => {
                // ä¸ºæ¯ä¸ªè·Ÿéšè€…ç”ŸæˆXã€Yåæ ‡è¾“å…¥æ¡†ï¼Œæ ‡ç­¾æ˜¾ç¤ºæ›¿æ¢åçš„åå­—
                html += `
                    <div>
                        <label>${carId.replace('CAR', 'ROBOT#')} X:</label>
                        <input type="number" id="${carId}X" class="coord-input" value="0" step="0.1">
                    </div>
                    <div>
                        <label>${carId.replace('CAR', 'ROBOT#')} Y:</label>
                        <input type="number" id="${carId}Y" class="coord-input" value="0" step="0.1">
                    </div>
                `;
            });

            return html;
        }

        // è®¾ç½®é»˜è®¤åç§»é‡
        function setDefaultOffsets(formationType, leaderId) {
            const defaults = {
                'line': {
                    'CAR1': {x: 0, y: 0},
                    'CAR2': {x: -0.7, y: 0},
                    'CAR3': {x: -1.4, y: 0},
                    'CAR4': {x: -2.1, y: 0}
                },
                'Diamond': {
                    'CAR1': {x: 0, y: 0},
                    'CAR2': {x: -0.7, y: -0.7},
                    'CAR3': {x: -0.7, y: 0.7},
                    'CAR4': {x: -1.4, y: 0}
                },
                'square': {
                    'CAR1': {x: 0, y: 0},
                    'CAR2': {x: 0, y: -0.7},
                    'CAR3': {x: -0.7, y: -0.7},
                    'CAR4': {x: -0.7, y: 0}
                }
            };

            const offsets = defaults[formationType] || defaults['line'];
            const allCars = ['CAR1', 'CAR2', 'CAR3', 'CAR4'];
            const followers = allCars.filter(carId => carId !== leaderId);

            followers.forEach(carId => {
                const offset = offsets[carId] || {x: 0, y: 0};
                const xInput = document.getElementById(`${carId}X`);
                const yInput = document.getElementById(`${carId}Y`);
                if (xInput) xInput.value = offset.x;
                if (yInput) yInput.value = offset.y;
            });
        }

        // å…³é—­å°è½¦è¯¦æƒ…å¼¹çª—
        function closeCarPopup() {
            carPopup.style.display = 'none';
        }

        // ç¼–é˜Ÿæ§åˆ¶å‡½æ•°
        async function startFormation() {
            const leaderId = document.getElementById('leaderSelector').value;
            const formationType = document.getElementById('formationType').value;

            try {
                const response = await fetch('/api/formation/start', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        leader_id: leaderId,
                        formation_type: formationType
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    updateFormationStatus(true, leaderId, formationType);
                    // æ˜¾ç¤ºåŠ¨æ€è°ƒæ•´é¢æ¿
                    document.getElementById('dynamicAdjustSection').style.display = 'block';
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('å¯åŠ¨ç¼–é˜Ÿå¤±è´¥:', error);
                showMessage('å¯åŠ¨ç¼–é˜Ÿå¤±è´¥', 'error');
            }
        }

        async function stopFormation() {
            try {
                const response = await fetch('/api/formation/stop', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    updateFormationStatus(false);
                    // éšè—åŠ¨æ€è°ƒæ•´é¢æ¿
                    document.getElementById('dynamicAdjustSection').style.display = 'none';
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('åœæ­¢ç¼–é˜Ÿå¤±è´¥:', error);
                showMessage('åœæ­¢ç¼–é˜Ÿå¤±è´¥', 'error');
            }
        }

        async function setCustomFormation() {
            const leaderId = document.getElementById('leaderSelector').value;
            const customOffsetsText = document.getElementById('customOffsets').value;

            try {
                const customOffsets = JSON.parse(customOffsetsText);

                const response = await fetch('/api/formation/custom', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        leader_id: leaderId,
                        offsets: customOffsets
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                    updateFormationStatus(true, leaderId, 'custom');
                    document.getElementById('dynamicAdjustSection').style.display = 'block';
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('è®¾ç½®è‡ªå®šä¹‰ç¼–é˜Ÿå¤±è´¥:', error);
                showMessage('è‡ªå®šä¹‰ç¼–é˜Ÿæ ¼å¼é”™è¯¯ï¼Œè¯·æ£€æŸ¥JSONæ ¼å¼', 'error');
            }
        }

        // æ›´æ–°ç¼–é˜Ÿåç§»é‡ - ä¿®å¤æ”¯æŒæ‰€æœ‰å°è½¦
        async function updateFormationOffsets() {
            const leaderId = document.getElementById('leaderSelector').value;
            const allCars = ['CAR1', 'CAR2', 'CAR3', 'CAR4'];
            const followers = allCars.filter(carId => carId !== leaderId);

            const offsets = {};

            // ä¸ºæ¯ä¸ªè·Ÿéšè€…æ”¶é›†åç§»é‡
            followers.forEach(carId => {
                const x = parseFloat(document.getElementById(`${carId}X`).value) || 0;
                const y = parseFloat(document.getElementById(`${carId}Y`).value) || 0;
                offsets[carId] = {"x": x, "y": y, "yaw": 0};
            });

            try {
                const response = await fetch('/api/formation/update_offsets', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        offsets: offsets
                    })
                });

                const result = await response.json();
                if (result.success) {
                    showMessage(result.message, 'success');
                } else {
                    showMessage(result.error, 'error');
                }
            } catch (error) {
                console.error('æ›´æ–°ç¼–é˜Ÿåç§»é‡å¤±è´¥:', error);
                showMessage('æ›´æ–°ç¼–é˜Ÿåç§»é‡å¤±è´¥', 'error');
            }
        }

        function updateFormationStatus(enabled, leaderId = '', formationType = '') {
            const statusElement = document.getElementById('formationStatus');
            if (enabled) {
                statusElement.innerHTML = `çŠ¶æ€: <span style="color: #48bb78;">ç¼–é˜Ÿä¸­</span> - é¢†èˆªè€…: ${leaderId.replace('CAR', 'ROBOT#')}, é˜Ÿå½¢: ${formationType}`;
            } else {
                statusElement.innerHTML = 'çŠ¶æ€: <span style="color: #f56565;">æœªå¯åŠ¨</span>';
            }
        }

        // æ˜¾ç¤º/éšè—è‡ªå®šä¹‰ç¼–é˜Ÿè®¾ç½®
        document.getElementById('formationType').addEventListener('change', function() {
            const customSection = document.getElementById('customFormationSection');
            if (this.value === 'custom') {
                customSection.style.display = 'block';
            } else {
                customSection.style.display = 'none';
            }
        });

        // é¢†èˆªè€…é€‰æ‹©å˜åŒ–æ—¶æ›´æ–°åŠ¨æ€è°ƒæ•´é¢æ¿
        document.getElementById('leaderSelector').addEventListener('change', function() {
            updateDynamicAdjustSection(this.value);
        });

        // æ›´æ–°åŠ¨æ€è°ƒæ•´é¢æ¿
        function updateDynamicAdjustSection(leaderId) {
            const dynamicSection = document.getElementById('dynamicAdjustSection');
            const container = document.getElementById('followerInputsContainer');

            // ç”Ÿæˆæ–°çš„è¾“å…¥æ¡†
            container.innerHTML = generateFollowerInputs(leaderId);

            // è®¾ç½®é»˜è®¤å€¼ï¼ˆæ ¹æ®é˜Ÿå½¢ç±»å‹ï¼‰
            const formationType = document.getElementById('formationType').value;
            setDefaultOffsets(formationType, leaderId);
        }

        // é˜Ÿå½¢ç±»å‹å˜åŒ–æ—¶ä¹Ÿæ›´æ–°é»˜è®¤å€¼
        document.getElementById('formationType').addEventListener('change', function() {
            const leaderId = document.getElementById('leaderSelector').value;
            setDefaultOffsets(this.value, leaderId);
        });

        // å®šæœŸè·å–ç¼–é˜ŸçŠ¶æ€
        async function getFormationStatus() {
            try {
                const response = await fetch('/api/formation/status');
                const status = await response.json();
                if (status.formation_enabled) {
                    updateFormationStatus(true, status.formation_leader, status.formation_type);
                    document.getElementById('dynamicAdjustSection').style.display = 'block';
                } else {
                    updateFormationStatus(false);
                    document.getElementById('dynamicAdjustSection').style.display = 'none';
                }
            } catch (error) {
                console.error('è·å–ç¼–é˜ŸçŠ¶æ€å¤±è´¥:', error);
            }
        }

        // åœ¨é¡µé¢åŠ è½½æ—¶åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            // åˆå§‹åŒ–é˜Ÿå½¢é¢„è§ˆ
            initFormationPreview();
            
            // åŠ è½½é»˜è®¤é˜Ÿå½¢é¢„è§ˆ
            loadFormationPreview('line');

            // åˆå§‹åŒ–åŠ¨æ€è°ƒæ•´é¢æ¿
            const initialLeader = document.getElementById('leaderSelector').value;
            updateDynamicAdjustSection(initialLeader);

            // å¼€å§‹å®šæœŸè·å–çŠ¶æ€
            setInterval(getFormationStatus, 3000);
        });

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            initCoordinateMap();

            // æ˜¾ç¤ºå¹¿æ’­é…ç½®ä¿¡æ¯
            checkNetworkStatus();

            // åˆå§‹è·å–å°è½¦æ•°æ®
            fetchCars();

            // æ›´å¿«çš„æ›´æ–°é¢‘ç‡ï¼šæ¯150msæ›´æ–°ä¸€æ¬¡
            setInterval(fetchCars, 150);

            // å°è½¦é€‰æ‹©å™¨å˜åŒ–äº‹ä»¶
            document.getElementById('carSelector').addEventListener('change', function() {
                selectedCarId = this.value;
                updateCarList();
            });

            // è·å–å¹¿æ’­çŠ¶æ€
            getBroadcastStatus();

            // å®šæœŸæ›´æ–°å¹¿æ’­çŠ¶æ€
            setInterval(getBroadcastStatus, 5000);

            // è·å–æ‹“æ‰‘çŠ¶æ€
            getTopologyStatus();

            // å®šæœŸæ›´æ–°æ‹“æ‰‘çŠ¶æ€
            setInterval(getTopologyStatus, 5000);

            // æ·»åŠ ç‚¹å‡»å°è½¦äº‹ä»¶ç›‘å¬
            canvas.addEventListener('click', function(e) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»äº†å°è½¦
                cars.forEach(car => {
                    if (!car.connected) return;

                    const carX = coordinateToPixelX(car.position.x);
                    const carY = coordinateToPixelY(car.position.y);

                    // ç®€å•åˆ¤æ–­ç‚¹å‡»æ˜¯å¦åœ¨å°è½¦é™„è¿‘
                    const distance = Math.sqrt(Math.pow(x - carX, 2) + Math.pow(y - carY, 2));
                    if (distance < 30) {
                        showCarPopup(car.id, e.clientX, e.clientY);
                        selectCar(car.id);
                    }
                });
            });

            console.log('ğŸš€ æ™ºèƒ½å°è½¦åæ ‡ç›‘æ§ç³»ç»Ÿå·²å¯åŠ¨ - è§’åº¦ç³»ç»Ÿ: 0Â°=Xè½´æ­£å‘, é€†æ—¶é’ˆå¢åŠ ');
            console.log('ğŸ“¡ å¹¿æ’­é…ç½®:', BROADCAST_CONFIG);
            console.log('ğŸŒ ç¡®ä¿å°è½¦ç›‘å¬ç«¯å£:', BROADCAST_CONFIG.port);
            console.log('ğŸ’¡ æ”¯æŒç²¾ç®€æ•°æ®æ ¼å¼å’Œå®Œæ•´æ•°æ®æ ¼å¼');
            console.log('ğŸ“Š æ˜¾ç¤ºæ‰€æœ‰é€Ÿåº¦åˆ†é‡: Vx(çº¿æ€§é€Ÿåº¦X), Vy(çº¿æ€§é€Ÿåº¦Y), Vz(è§’é€Ÿåº¦Z)');
            console.log('ğŸ”— æ”¯æŒé€šä¿¡æ‹“æ‰‘çŸ©é˜µæ§åˆ¶');
            console.log('ğŸ“ åæ ‡èŒƒå›´: X[' + COORDINATE_RANGE.minX + ', ' + COORDINATE_RANGE.maxX + '], Y[' + COORDINATE_RANGE.minY + ', ' + COORDINATE_RANGE.maxY + ']');
        });
    </script>
</body>
</html>